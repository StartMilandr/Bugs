# Bugs

В репозитории представлены проекты, демонстрирующие аппаратные недостатки (ошибки) в МК и пути их обхода в ПО.


## 1901_McBSP_FrameByFIFO

Микроконтроллер 1901ВЦ1Т, блок McBSP.

Пример показывает отсутствие сигнала кадровой синхронизации при настройке формирования этого сигнала по поступлению данных из FIFO в передатчик.


## Power_PVD

Пример демонстрирует необходимость двойного сброса флага PVD (регистр  PVDCS) блок POWER в МК 1986ВЕ1Т и 1986ВЕ9х (на примере 1986ВЕ92У)

Подробное описание в статье - https://startmilandr.ru/doku.php/prog:bug:pvd_test


## Power_PVD_VE8

Пример демонстрирует проблему с выставлением уровня ULIMIT в блоке POWER и вариант его обхода в МК 1986ВЕ8Т


## Timer_EventClear
При сбросе флага события в регистре STATUS последней командой в таймерном прерывании, возникает вторичное прерывание. (1986ВЕ9х, 1986ВЕ8Т)


## RTC_HSI_OFF
Выключение генератора HSI в МК серии 1986ВЕ9х.

Пример показывает обход ошибки Errata - "0004 Невозможность выключить генератор HSI при нулевом ALRF", а так же то, что если после выключения HSI сбросить бит ALRF, HSI запускается вновь.

Подробнее в заметке - https://startmilandr.ru/doku.php/prog:bug:hsi_off_ve9x


## CAPSyncChannels

Задержка обновления регистра захвата CCR - считывается старое значение.

Ошибка аналогична описанию в errata 0015. При частоте CPU_Clock много большей, чем TIM_Clock, ПО вычитывает регистр CCR в прерывании раньше, чем регистр обновляется новым значением захвата. Эта ошибка помечена как исправленая, но по факту проявляется при захвате одного сигнала двумя разными каналами таймера. (Такое-же поведение возникает, если два входных синхронных сигнала два, поданы на два канала таймера.)

В проекте каналы таймера CH3 и CH2 захватывают фронт на входе TMR1_CH3 (CH2 захватывает сигнал с входа выбранного для CH3). При этом при считывании регистров захвата CCR2 и CCR3, значения считываются сильно разные - в регистр CCR2 не успевает обновляться и возвращает предыдущее значение. Лог регистров представлен на картинке CAP_Bug.png.

Поведение исправлется если:
  - Внести задержку перед считыванием CCR2 и CCR3. Но это не всегда уместно, поскольку обработчик прерывания желательно делать короче, чтобы не пропустить следующие прерывания.
  - Повысить частоту TIM_Clock, чтобы таймер "побыстрее" обновлял регистры. В данном случае и захват происходит с большей точностью.

Пример показывает, что задержка с обновлением CCR2 возникает при использовании делителя TIM_CLock.TIM1_BRG = 5, т.е. TIM1_Clock = CPU_Clock/32. При делителе TIM_CLock.TIM1_BRG = 4 (TIM_Clock = CPU_Clock/16) ошибка не наблюдается.

Проект собран для 1986ВЕ91Т, т.е. будет проявляться во всей серии 1986ВЕ9х. Но поскольку таймеры во многих микроконтроллерах одинаковы, то ошибка скорее всего активна и для них.


## 1901_Req_DMA_from_AUC

DMA_ADC_VC1 - адаптация примера измерения АЦП с использованием DMA от 1986ВЕ92У для 1901ВЦ1. 
https://github.com/StartMilandr/6.x-DMA_Projects/tree/master/6.5-DMA_ADC/DMA_ADC_VExx

При включении тактирования ядра DSP возникает проблема, выражающаяся в том, что исполнение не выходит из обработчика прерывания DMA_IRQHandler().
Выяснилось, что к DMA висит активный запрос от FIFO ЦАПа аудиокодека, хотя тот и не включен.
В примере показаны два варианта решения проблемы, можно:
  * Разрешить работу канала DMA через запись MDR_DMA->CHNL_ENABLE_SET |= (1UL << 23), где 23 - это и есть номер канала AUC_FIFO_DAC.
  * Либо заполнить FIFO ЦАПа любыми значениями не включая сам ЦАП. Этот вариант реализован в функции BRD_ClockDSP_Init_HSE_PLL_fixDMAIRQ(), которая вынесена в модуль brdClock.c.

Макроопределения в начале main.c выбирают тот, или иной вариант. Если пути обхода не выбраны, то исполнение застревает в DMA_IRQHandler().
  #define FIX_BY_DMA_EN_AUC          0
  #define FIX_BY_FILL_AUC_DAC_FIFO   0

### ИНДИКАЦИЯ:
При перезапуске циклов DMA переключается светодиод PB15 на отладочной плате
  * PB15 мигает - исправная работа
  * PB15 НЕ мигает - программа висит в обработчике DMA_IRQHandler


