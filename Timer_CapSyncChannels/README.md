# CAPSyncChannels

Задержка обновления регистра захвата CCR - считывается старое значение.

Ошибка аналогична описанию в errata 0015. При частоте CPU_Clock много большей, чем TIM_Clock, ПО вычитывает регистр CCR в прерывании раньше, чем регистр обновляется новым значением захвата. Эта ошибка помечена как исправленая, но по факту проявляется при захвате одного сигнала двумя разными каналами таймера. (Такое-же поведение возникает, если два входных синхронных сигнала два, поданы на два канала таймера.)

В проекте каналы таймера CH3 и CH2 захватывают фронт на входе TMR1_CH3 (CH2 захватывает сигнал с входа выбранного для CH3). При этом при считывании регистров захвата CCR2 и CCR3, значения считываются сильно разные - в регистр CCR2 не успевает обновляться и возвращает предыдущее значение. Лог регистров представлен на картинке CAP_Bug.png.

Поведение исправлется если:
  - Внести задержку перед считыванием CCR2 и CCR3. Но это не всегда уместно, поскольку обработчик прерывания желательно делать короче, чтобы не пропустить следующие прерывания.
  - Повысить частоту TIM_Clock, чтобы таймер "побыстрее" обновлял регистры. В данном случае и захват происходит с большей точностью.

Пример показывает, что задержка с обновлением CCR2 возникает при использовании делителя TIM_CLock.TIM1_BRG = 5, т.е. TIM1_Clock = CPU_Clock/32. При делителе TIM_CLock.TIM1_BRG = 4 (TIM_Clock = CPU_Clock/16) ошибка не наблюдается.

Проект собран для 1986ВЕ91Т, т.е. будет проявляться во всей серии 1986ВЕ9х. Но поскольку таймеры во многих микроконтроллерах одинаковы, то ошибка скорее всего активна и для них.

## Аппаратное исправление

По запросу в ТП выяснилось, что блок таймера уже содержит аппаратный способ обхода ошибки с задержкой обновления регистров CCR.
Если выставить бит 4 в регистре CHx_CNTRL2, то генерация события задерживается на один такт, чтобы успели обновиться значения CCR. Таким образом к моменту срабатывания прерывания значения в регистрах уже заведомо обновлены свежим значением захвата.

К сожалению, данный способ обхода выключен по умолчанию и не попал ни в спецификацию, ни в errata. Документацию обещали доработать после перепроверки работоспособности данного бита на всех микроконтроллерах с аналогичным блоком таймера.

Проблема с захватом в 1986ВЕ9х исчезает, если добавить в инициализации следующий код:
   MDR_TIMER1->CH2_CNTRL2 = (1 << 4);
   MDR_TIMER1->CH3_CNTRL2 = (1 << 4);


